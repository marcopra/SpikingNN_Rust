use crate::{nn::{Spike, NN}, Model};
use ndarray::{Array2, OwnedRepr, ArrayBase, Dim};


/// This struct is used to manage the input spikes given a NN,
/// to generate the output spikes.
pub struct Solver<M: Model>{
    input_spikes: Vec<Spike>,
    network: NN<M>,
}

/// This struct is used to manage the internal vars of a Neuron
struct SimulatedNeuron<M: Model> { 
    vars: M::SolverVars
}

impl<M: Model> SimulatedNeuron<M> 
where for <'a> &'a M::Neuron: Into<M::SolverVars> {

    ///Build a new instance of [SimulatedNeuron] given a [Neuron].
    /// 
    /// The [SimulatedNeuron] initially contains the same internals vars of the reference [Neuron].
    pub fn new(neuron: &M::Neuron) -> SimulatedNeuron<M>{
        SimulatedNeuron { vars: neuron.into()}
    }
}

/// This struct is used to manage the internal vars of a NN
struct SimulatedNN<M: Model> {
    layers: Vec<Vec<SimulatedNeuron<M>>>
}

impl<M: Model> SimulatedNN<M> {
    ///Build a new instance of [SimulatedNN].
    fn new() -> Self{
        Self { 
            ///Vector that contains all the layers inside the NN.
            layers: Vec::new(),
        }
    }

    ///This method adds a new layer to [SimulatedNN].
    fn add_layer(&mut self, layer: Vec<SimulatedNeuron<M>>){
        self.layers.push(layer);
    }
}

impl<M: Model> Solver<M> 
where for <'a> &'a M::Neuron: Into<M::SolverVars> {
    
    ///Build a new instance of [Solver], needed to solve the network given the input spikes vector.
    pub fn new(input_spikes: Vec<Spike>, network: NN<M>) -> Solver<M> {
        Solver { 
            input_spikes, 
            network 
        }
    }

    /// Each spike of the input_spike vec is sent to the corresponding neuron 
    /// of the input layer, one by one.
    pub fn solve(&mut self) -> Vec<Vec<u128>>{

        //Inizialization of Neuron variables
        let mut sim_network = Self::init_neuron_vars(&(self.network));
        let mut nn_output: Vec<Vec<u128>> = Vec::new();
        

        //Iteration over the spikes input vector
        for spike in self.input_spikes.iter() {

            //Input dimension taken from layers 0 (1st Layer)
            let dim_input = self.network.layers[0].neurons.len();

            //Spike array creation, involved in a multiplication with the first (diagonal) weight matrix (input matrix).
            let spike_array = single_spike_to_vec(spike.neuron_id, dim_input);

            //Propagation of spikes inside the network
            let res = Solver::infer_spike_vec(&self.network, &mut sim_network, spike_array, spike.ts);
        
            nn_output.push(res);
        }
    

        // Computing the output of the NN
        let mut output = vec![vec![]; self.network.layers.last().unwrap().neurons.len()];

        for spike in nn_output {
            for (neuron_id, ts) in spike.into_iter().enumerate().filter(|(_, v)| *v != u128::MAX) {
                output[neuron_id].push(ts);
            }
        }
        output
    }

    /// _*--> (Internal Use Only)*_
    /// 
    /// Create a temporary NN, parallel to the real one passed as a parameter
    /// 
    /// This new NN will contain only variables like v_mem, ts_old etc
    fn init_neuron_vars(network: & NN<M>) -> SimulatedNN<M> {
        
        let mut sim_nn = SimulatedNN::new();
        let mut sim_neuron: SimulatedNeuron<M>;
        let mut sim_layer: Vec<SimulatedNeuron<M>>;

        for layer in network.layers.iter() {
            sim_layer = Vec::with_capacity(layer.neurons.len());

            for neuron in layer.neurons.iter() {
                sim_neuron = SimulatedNeuron::new(neuron);
                sim_layer.push(sim_neuron);
            }
            sim_nn.add_layer(sim_layer);
        }
        sim_nn
    }

    /// Propagate Spikes inside the network and then creates a Vec of spikes.
    fn infer_spike_vec(
                network: & NN<M>, 
                sim_network: &mut SimulatedNN<M>, 
                spike_vec: ArrayBase<OwnedRepr<f64>, 
                Dim<[usize; 2]>>, 
                ts: u128) -> Vec<u128> {

        //Creation of the output spikes vector
        let mut out_spikes: Vec<u128> = Vec::new();

        //Creation of output vector containing the spikes generated by neurons
        let mut output_vec: Vec<f64> = Vec::new();

        //Creation of vector that contains the variables of the i-th simulatedLayer
        let mut neuron_vars: &mut Vec<SimulatedNeuron<M>> ;
        
        let mut current_spike_vec = spike_vec;

        // We compute for each neuron inside the layer its output (if it generates a spike or not)
        for (cnt, (layer, sim_layer)) in network.layers.iter().zip(&mut sim_network.layers).enumerate(){
            
            //Variables of i-th layer
            neuron_vars = sim_layer;

    
            //We use `current_spike_vec` (vector containing the spikes generated by the previous layer)
            //to compute the weighted spikes received to the current layer, we use a dot product.
            let weighted_input_val = current_spike_vec.dot(&layer.input_weights);

        
            // For each neuron in the layer, we use the `handle_spike` function given the neuron parameters and variables and 
            // the previously computed input. We can obtain a spike (`1`) or not (`0`) 
            for (i, neuron) in layer.neurons.iter().enumerate(){
                
                let res = M::handle_spike(neuron, 
                    &mut neuron_vars[i].vars, 
                    weighted_input_val[[0,i]], 
                    ts);
                output_vec.push(res);
            }

            //We update the `current_spike_vec` with the obtained results
            current_spike_vec =  Array2::from_shape_vec([1, output_vec.len()], output_vec.clone()).unwrap();

            // Check if the current layer is the last layer.
            if cnt == network.layers.len() - 1 {
                out_spikes = to_u128_vec(&output_vec, ts);  
            }

            // Empty the spike vector generated by neurons to make 
            // the vector ready for the next iterations over the layers
            output_vec.clear();

            // Creation of the input vector with values recived by neurons in the same layers. We use a dot product.
            let intra_layer_input_val = current_spike_vec.dot(&layer.intra_weights);

            // For each neuron in the layer, we use the `handle_spike` function given the neuron parameters and variables and 
            // the computed input considering the intra-layer links. We can obtain a spike (`1`) or not (`0`).
            // Here, using `handle_spike`, we update the internal `vars` 
            for (i, neuron) in layer.neurons.iter().enumerate(){
                
                M::handle_spike(neuron, 
                    &mut neuron_vars[i].vars, 
                    intra_layer_input_val[[0,i]], 
                    ts);
            }
        }

        out_spikes
        


    }

}

    /// Create a zero array, but with a single '1' in the neuron_id-th position
    /// 
    /// # Example 
    /// 
    /// ```ignore
    /// # use ndarray::Array2;
    /// # use super::single_spike_to_vec;
    /// let neuron_id = 2; //The neuron ids start from 0
    /// let dim  = 4;
    /// 
    /// assert_eq!(single_spike_to_vec(neuron_id, dim).as_slice().unwrap(), &[0.0, 0.0, 1.0, 0.0]);
    /// ```  
    fn single_spike_to_vec(neuron_id: usize, dim: usize) -> ArrayBase<OwnedRepr<f64>, Dim<[usize; 2]>> {

        let mut res: Vec<f64> = Vec::new();

        for i in 0..dim {
            if i == neuron_id {res.push(1.);}
            else {res.push(0.)}
        }
        Array2::from_shape_vec([1, dim], res).unwrap()
    }

    /// Create a vec of u128 (val_to_set) starting from a f64 array and a val to use if the f64 is greater than 0 
    /// 
    /// If in the i-th position the val of he input vec is greater than 0, the new vec will have 'val_to_set in that position, otherwise it will have a 0
    fn to_u128_vec<'a, T>(vec: T, val_to_set: u128) -> Vec<u128>
    where T: IntoIterator<Item = &'a f64>
    {
        let mut res: Vec<u128> =  Vec::new();

        for &val in vec {
            if val > 0.0 { res.push(val_to_set) }
            else { res.push(u128::MAX) };
        }   
        res 
    }

#[cfg(test)]
mod tests {
    

    use crate::{lif::{LifNeuronConfig, LeakyIntegrateFire, LifNeuron, LifSolverVars}, Spike, NNBuilder, nn::{solver_v1::Solver}};

    #[test]
    fn test_init_simulated_nn() {
        let config = LifNeuronConfig::new(2.0, 0.5, 2.1, 1.0);
    
        let nn = NNBuilder::<LeakyIntegrateFire, _>::new()
            .layer(
                [
                    From::from(&config),
                    From::from(&config),
                    From::from(&config)
                ],
                [
                    1.0, 1.0, 1.0
                ],
                [
                    [0.0, 0.0, 0.0],
                    [0.0, 0.0, 0.0],
                    [0.0, 0.0, 0.0]
                ]
            )
            .build();
        
        let mut sim_nn = Solver::init_neuron_vars(&(nn));
        

        
        let mut equal :bool = true;

        for (layer, sim_layer) in nn.layers.iter().zip(&mut sim_nn.layers){
            for (neuron, sim_neuron) in &mut layer.neurons.iter().zip(sim_layer) {

                let sim_v_mem;
                let sim_ts_old;
                let v_mem;
                let ts_old;
                (sim_v_mem, sim_ts_old) = sim_neuron.vars.get_vars();
                
                let mut vars : LifSolverVars  = neuron.into();
                (v_mem, ts_old ) = vars.get_vars();
                
                if (v_mem != sim_v_mem) || (ts_old != sim_ts_old) {
                    equal = false;
                }

            }

        }

        assert!(equal);

    }


    #[test]
    fn test_passthrough_nn_using_solver() {

        let config = LifNeuronConfig::new(2.0, 0.5, 2.1, 1.0);
    
        let nn = NNBuilder::<LeakyIntegrateFire, _>::new()
            .layer(
                [
                    From::from(&config),
                    From::from(&config),
                    From::from(&config)
                ],
                [
                    1.0, 1.0, 1.0
                ],
                [
                    [0.0, 0.0, 0.0],
                    [0.0, 0.0, 0.0],
                    [0.0, 0.0, 0.0]
                ]
            )
            .build();
        
        let spikes = Spike::create_terminal_vec(
            vec![
                Spike::spike_vec_for(0, vec![1, 2, 3, 5, 6, 7]),
                Spike::spike_vec_for(1, vec![2, 6, 7, 9]),
                Spike::spike_vec_for(2, vec![2, 5, 6, 10, 11])
            ]
        );

        let mut solver = Solver::new(spikes, nn);

        assert_eq!(
            solver.solve(),
            vec![
                vec![1, 2, 3, 5, 6, 7],
                vec![2, 6, 7, 9],
                vec![2, 5, 6, 10, 11]
            ]
        );
    }

    #[test]
    fn test_correct_management_of_example_spike(){

        let nn = NNBuilder::<LeakyIntegrateFire, _>::new()
        .layer(
            [
                LifNeuron::new(&LifNeuronConfig::new(2.0, 0.5, 3.0, 1.6)),
                LifNeuron::new(&LifNeuronConfig::new(1.5, 0.4, 3.1, 1.2)),
                LifNeuron::new(&LifNeuronConfig::new(1.6, 0.3, 2.8, 1.1))
            ],
            [1.1, 1.2, 1.1],
            [
                [0.0, -0.1, -0.2],
                [-0.15, 0.0, -0.1],
                [-0.2, -0.15, 0.0]
            ]
        )
        .layer(
            [
                LifNeuron::new(&LifNeuronConfig::new(1.8, 0.5, 2.8, 1.5)),
                LifNeuron::new(&LifNeuronConfig::new(1.7, 0.8, 2.6, 1.6))
            ],
            [
                [0.9, 0.85],
                [0.8, 0.9],
                [0.85, 0.7]
            ],
            [
                [0.0, -0.2],
                [-0.15, 0.0]
            ]
        )
        .build();

    let spikes = Spike::create_terminal_vec(
        vec![
            Spike::spike_vec_for(0, vec![2, 5, 6, 10]),
            Spike::spike_vec_for(1, vec![3, 7, 8, 10]),
            Spike::spike_vec_for(2, vec![4, 9, 12])
        ]
    );


    let mut solver = Solver::new(spikes, nn);

    assert_eq!(
        solver.solve(),
        vec![
            vec![8],
            vec![6]
        ]
    );

    }
}
